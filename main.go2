package main

import (
	"fmt"
	"reflect"
	"strconv"
)

func main() {

	{
		ints := []int{1, 2, 3}
		exp := []string{"1", "2", "3"}

		res := Map(ints, func(_ int, i int) string {
			return fmt.Sprintf("%d", i)
		})
		fmt.Println("---- Test Map ----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v", res, exp)
		}
	}
	{
		ints := []int{1, 2}
		exp := []string{"1", "1", "2", "2"}

		res := FlatMap(ints, func(_ int, i int) []string {
			str := fmt.Sprintf("%d", i)
			return []string{str, str}
		})
		fmt.Println("---- Test FlatMap ----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v", res, exp)
		}
	}

	{
		ints := []int{1, 2, 3}
		exp := "123"
		res := FoldLeft(ints, func(_ int, acc string, i int) string {
			return fmt.Sprintf("%s%d", acc, i)
		}, "")
		fmt.Println("---- Test FoldLeft ----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v", res, exp)
		}
	}

	{
		ints := []int{1, 2, 3}
		exp := "321"
		res := FoldRight(ints, func(_ int, acc string, i int) string {
			return fmt.Sprintf("%s%d", acc, i)
		}, "")
		fmt.Println("---- Test FoldRight ----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}

	{
		ints := []int{1, 2, 3}
		exp := []int{2, 3}
		res := DropLeft(ints, 1)
		fmt.Println("---- Test DropLeft ----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}
	{
		ints := []int{1, 2, 3}
		exp := []int{1, 2}
		res := DropRight(ints, 1)
		fmt.Println("---- Test DropRight ----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}

	{
		ints := []int{1, 2, 3}
		exp := []int{3}
		res := DropLeftWhile(ints, func(_ int, a int) bool {
			return a < 3
		})
		fmt.Println("---- Test DropLeftWhile ----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}
	{
		ints := []int{1, 2, 3}
		exp := []int{1}
		res := DropRightWhile(ints, func(_ int, a int) bool {
			return a > 1
		})
		fmt.Println("---- Test DropRightWhile ----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}
	{
		ints := []int{1, 2, 3}
		exp := []int{1, 2}
		res := TakeLeft(ints, 2)
		fmt.Println("---- Test TakeLeft ----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}
	{
		ints := []int{1, 2, 3}
		exp := []int{2, 3}
		res := TakeRight(ints, 2)
		fmt.Println("---- Test TakeRight ----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}
	{
		ints := []int{1, 2, 3}
		exp := []int{1, 3}
		res := Filter(ints, func(_ int, a int) bool {
			return a%2 == 1
		})
		fmt.Println("---- Test Filter ----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}
	{
		ints := []int{1, 2, 3}
		exp := []int{1, 3}
		res := Reject(ints, func(_ int, a int) bool {
			return a == 2
		})
		fmt.Println("---- Test Reject ----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}

	{
		ints := []int{1, 2, 3}
		exp := true
		res := Some(ints, func(a int) bool {
			return a == 2
		})
		fmt.Println("---- Test Some 1----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}
	{
		ints := []int{1, 2, 3}
		exp := false
		res := Some(ints, func(a int) bool {
			return a == 5
		})
		fmt.Println("---- Test Some 2----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}
	{
		ints := []int{1, 2, 3}
		exp := true
		res := None(ints, func(a int) bool {
			return a == 5
		})
		fmt.Println("---- Test None 1----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}
	{
		ints := []int{1, 2, 3}
		exp := false
		res := None(ints, func(a int) bool {
			return a == 2
		})
		fmt.Println("---- Test None 2----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}
	{
		ints := []int{1, 2, 3}
		exp := true
		res := Every(ints, func(a int) bool {
			return a < 5
		})
		fmt.Println("---- Test Every 1----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}
	{
		ints := []int{1, 2, 3}
		exp := false
		res := Every(ints, func(a int) bool {
			return a < 3
		})
		fmt.Println("---- Test Every 2----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}

	{
		ints := []int{1, 2, 3}
		exp := 2
		res := Nth(ints, 1).OrElse(0)
		fmt.Println("---- Test Nth 1----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}
	{
		ints := []int{1, 2, 3}
		exp := 3
		res := Nth(ints, -1).OrElse(0)
		fmt.Println("---- Test Nth 2----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}
	{
		ints := []int{1, 2, 3}
		exp := 0
		res := Nth(ints, 10).OrElse(0)
		fmt.Println("---- Test Nth 3----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}

	{
		ints := []int{1, 2, 3}
		exp := true
		res := Has(ints, 2, func(a, b int) bool {
			return a == b
		})
		fmt.Println("---- Test Has 1----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}
	{
		ints := []int{1, 2, 3}
		exp := false
		res := Has(ints, 0, func(a, b int) bool {
			return a == b
		})
		fmt.Println("---- Test Has 2----")
		if !reflect.DeepEqual(res, exp) {
			fmt.Printf("expected, %v to equal %v\n", res, exp)
		}
	}

	{
		isEven := func(_ int, a int) bool { return a%2 == 0 }
		ints := []int{1, 2, 3, 4}
		expEven := []int{2, 4}
		expOdd := []int{1, 3}
		even, odd := Partition(ints, isEven)
		fmt.Println("---- Test Partition 1----")
		if !reflect.DeepEqual(even, expEven) {
			fmt.Printf("expected, %v to equal %v\n", even, expEven)
		}
		if !reflect.DeepEqual(even, expEven) {
			fmt.Printf("expected, %v to equal %v\n", odd, expOdd)
		}
	}

	{
		as := []int{1, 2, 3, 4}
		bs := []string{"a", "b", "c"}
		exp := []string{"1a", "2b", "3c"}
		res := Zip(as, bs, func(a int, b string) string {
			return fmt.Sprintf("%d%s", a, b)
		})
		fmt.Println("---- Test Zip 1----")
		if !reflect.DeepEqual(exp, res) {
			fmt.Printf("expected, %v to equal %v\n", exp, res)
		}
	}

	{
		cs := []string{"1a", "2b", "3c"}

		expA := []int{1, 2, 3}
		expB := []string{"a", "b", "c"}

		a, b := Unzip(cs, func(c string) (int, string) {
			a, _ := strconv.Atoi(string(c[0]))
			return a, string(c[1])
		})
		fmt.Println("---- Test Unzip 1----")
		if !reflect.DeepEqual(expA, a) {
			fmt.Printf("expected, %v to equal %v\n", expA, a)
		}
		if !reflect.DeepEqual(expB, b) {
			fmt.Printf("expected, %v to equal %v\n", expB, b)
		}
	}

	{
		a := []int{1, 2, 3}

		exp := map[string]int{
			"[1]": 1,
			"[2]": 2,
			"[3]": 3,
		}

		m := KeyBy(a, func(_ int, a int) string {
			return fmt.Sprintf("[%d]", a)
		})
		fmt.Println("---- Test KeyBy ----")
		if !reflect.DeepEqual(exp, m) {
			fmt.Printf("expected, %v to equal %v\n", exp, m)
		}
	}

	{
		a := []int{1, 2, 3}

		exp := map[string][]int{
			"0": {2},
			"1": {1,3},
		}

		m := GroupBy(a, func(_ int, a int) string {
			return fmt.Sprintf("%d", a % 2)
		})
		fmt.Println("---- Test GroupBy----")
		if !reflect.DeepEqual(exp, m) {
			fmt.Printf("expected, %v to equal %v\n", exp, m)
		}
	}

	//{
	//	a := []int{1, 2, 3,4,5,6,7,8}
	//
	//	//fmt.Println(Sample(a, 0))
	//	fmt.Println(Sample(a, 4))
	//	fmt.Println("a", a)
	//
	//	fmt.Println(Sample(a, 3))
	//	fmt.Println("a", a)
	//
	//	fmt.Println(Sample(a, 2))
	//	fmt.Println("a", a)
	//
	//
	//	fmt.Println(Sample(a, 1))
	//	fmt.Println("a", a)
	//
	//
	//}


}
